<!doctype html><html dir=ltr lang=en data-theme=dark class="html theme--dark"><head><meta charset=utf-8><title>Dmitry Kuznetsov
|
Mastering LLM Effectiveness in Development
</title><meta name=generator content="Hugo 0.143.1"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Dmitry Kuznetsov"><meta name=description content="Core principles for harnessing LLM (AI) in development effectively"><link rel=stylesheet href=/css/anatole.min.937053fd3776aee2007dab0765e5ed4ad40e2c9634e7c7e7e2a8451c3b9591db.css integrity="sha256-k3BT/Td2ruIAfasHZeXtStQOLJY058fn4qhFHDuVkds=" crossorigin=anonymous><link rel=stylesheet href=/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/override.min.582ab7f7a3a821d6afb051ea8d64a1c1c5855671991b429ffe3603fcf937f6cf.css integrity="sha256-WCq396OoIdavsFHqjWShwcWFVnGZG0Kf/jYD/Pk39s8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/404.min.8af5cba8db45fcd9bffa951d2cb07c1b34c55055091a151d255d39bc2ccfc919.css integrity="sha256-ivXLqNtF/Nm/+pUdLLB8GzTFUFUJGhUdJV05vCzPyRk=" crossorigin=anonymous media=screen><link rel=stylesheet href=/fontawesome/css/fontawesome.min.137b1cf3cea9a8adb7884343a9a5ddddf4280f59153f74dc782fb7f7bf0d0519.css integrity="sha256-E3sc886pqK23iENDqaXd3fQoD1kVP3TceC+3978NBRk=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.e65dc5b48fb5f39b142360c57c3a215744c94e56c755c929cc3e88fe12aab4d3.css integrity="sha256-5l3FtI+185sUI2DFfDohV0TJTlbHVckpzD6I/hKqtNM=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.6f4f16d58da1c82c0c3a3436e021a3d39b4742f741192c546e73e947eacfd92f.css integrity="sha256-b08W1Y2hyCwMOjQ24CGj05tHQvdBGSxUbnPpR+rP2S8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.e10425ad768bc98ff1fb272a0ac8420f9d1ba22f0612c08ff1010c95080ffe7e.css integrity="sha256-4QQlrXaLyY/x+ycqCshCD50boi8GEsCP8QEMlQgP/n4=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=https://kuznetsov.dev/en/posts/mastering-llm-in-development/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script><script type=text/javascript src=/js/redirect.min.0a6c00c0503228880893a70f3348da2a8ee321da80219f8b23ee33557045983b.js integrity="sha256-CmwAwFAyKIgIk6cPM0jaKo7jIdqAIZ+LI+4zVXBFmDs=" crossorigin=anonymous></script><script async defer data-domain=kuznetsov.dev src=https://analytics.flowmitry.com//js/script.file-downloads.outbound-links.tagged-events.js></script><script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Mastering LLM Effectiveness in Development"><meta name=twitter:description content="Core principles for harnessing LLM (AI) in development effectively"><meta property="og:url" content="https://kuznetsov.dev/en/posts/mastering-llm-in-development/"><meta property="og:site_name" content="Cult of Quality"><meta property="og:title" content="Mastering LLM Effectiveness in Development"><meta property="og:description" content="Core principles for harnessing LLM (AI) in development effectively"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-18T00:00:00+00:00"><meta property="article:tag" content="Llm"><meta property="article:tag" content="Ai"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Mastering LLM Effectiveness in Development","headline":"Mastering LLM Effectiveness in Development","alternativeHeadline":"","description":"
      Core principles for harnessing LLM (AI) in development effectively


    ","license":"","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/kuznetsov.dev\/en\/posts\/mastering-llm-in-development\/"},"author":{"@type":"Person","name":"Dmitry Kuznetsov"},"creator":{"@type":"Person","name":"Dmitry Kuznetsov"},"accountablePerson":{"@type":"Person","name":"Dmitry Kuznetsov"},"copyrightHolder":{"@type":"Person","name":"Dmitry Kuznetsov"},"dateCreated":"2025-06-18T00:00:00.00Z","datePublished":"2025-06-18T00:00:00.00Z","dateModified":"2025-06-18T00:00:00.00Z","publisher":{"@type":"Organization","name":"Dmitry Kuznetsov","url":"https://kuznetsov.dev/","logo":{"@type":"ImageObject","url":"https:\/\/kuznetsov.dev\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/kuznetsov.dev\/en\/posts\/mastering-llm-in-development\/","wordCount":"1929","genre":[],"keywords":["llm","ai"]}</script></head><body class=body><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
."><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/avatar-qq.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/en>Dmitry Kuznetsov</a></div><div class=sidebar__introduction-description><p>Build. Iterate. Automate.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/dmitry-kuznetsov-dev target=_blank rel="noopener me" aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin-in fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/flowmitry target=_blank rel="noopener me" aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://t.me/kuznetsov_dev target=_blank rel="noopener me" aria-label=Telegram title=Telegram><i class="fab fa-telegram-plane fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://x.com/flowmitry target=_blank rel="noopener me" aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Dmitry Kuznetsov
2025</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div></aside><main class=wrapper__main><header class=header><div class=.><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/en/ title>Posts</a></li><li class=nav__list-item><a href=/en/posts/ title>Posts archive</a></li><li class=nav__list-item><a href=/en/about/ title>About me</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=optionswitch><input class=optionswitch__picker type=checkbox id=languagepicker hidden>
<label class=optionswitch__label for=languagepicker>EN <i class="fa fa-angle-down" aria-hidden=true></i></label><div class=optionswitch__triangle></div><ul class=optionswitch__list><li class=optionswitch__list-item><a href=/posts/mastering-llm-in-development/ title=RU><span aria-label=RU>RU</span></a></li></ul></div></li></ul></nav></div></header><div class="post
."><div class=post__content><h1>Mastering LLM Effectiveness in Development</h1><p>I&rsquo;m always looking for ways to get more done in less time, and with the rise of AI, this is finally bringing real benefits to my development process. However, many developers don&rsquo;t see—or don&rsquo;t want to see—the opportunities opening up for us, and continue working the old-fashioned way, inadvertently putting themselves at risk of falling behind in the competition.</p><p>As an engineering manager, I interact with developers from all around the world, and I witness their vastly different attitudes towards AI. Generally, I break it down into these categories:</p><ul><li>Inspired and actively using AI in their work (up to 20%);</li><li>Interested, experimenting, but using AI for roughly 20% of tasks (about 60%);</li><li>Skeptics who either tried it and weren&rsquo;t impressed, or never tried it at all (around 20%).
The numbers are quite subjective and mostly reflect my own experience rather than being representative across the entire industry.</li></ul><p>There are studies showing that AI penetration in development is about 60%, which might actually be true. But for now, this figure mostly reflects the portion of developers who use ChatGPT, Perplexity, and similar AI-powered tools superficially, without deep practical integration. In practice, LLMs are mostly used at a surface level, even though their potential is enormous.</p><h1 id=about-my-experience>About My Experience</h1><p>Over the past year, I&rsquo;ve experimented with various editors and AI-powered IDE plugins, but I currently rely on Cursor AI, Github Copilot, and JetBrains Junie as my daily drivers for development.</p><p>I haven&rsquo;t studied the internal workings of LLMs in depth or read up on their architecture, but by constantly switching between different tools, I&rsquo;ve started to notice certain patterns. This eventually led me to conclusions that have made my use of LLMs in indie development much more effective (and I see no reason why this wouldn&rsquo;t also apply in a company setting—more on that in future posts).</p><p>My takeaways might not be rigorously accurate from a Data Science perspective (I welcome any feedback!), but this is how things work in simplified terms. I hope this will be useful to a wide range of developers and help clarify why models sometimes glitch, how they work, and what you can do about it.</p><h1 id=what-developers-complain-about>What Developers Complain About</h1><p>In this section, I’ll break down a few main issues developers raise, and explain why these problems occur.</p><p>I&rsquo;ll only cover fundamental principles and limitations, those that aren’t going anywhere for the foreseeable future. For now, we are witnessing various clever workarounds emerge—and we’re using them ourselves.</p><h2 id=problem-1-llms-hallucinate>Problem #1: LLMs hallucinate</h2><p>I liked this quote: “LLMs hallucinate 100% of the time, but 80% of the time they&rsquo;re right.” Every LLM I know always tries to provide you with an answer—even if it’s wrong. Fundamentally, this is hard to solve. However, it’s important to realize that hallucinations can stem from several causes, and some of those can be tackled individually. In this section I&rsquo;ll discuss one of these causes.</p><p>Starting with theory: Every model has a limited <strong>context window</strong>—the amount of text the LLM can consider or “remember” at one time when generating a reply. The context window is measured in tokens, but a token isn’t always the same length. As a rough estimate, consider 1 English token to be about 4 characters, or about 75 English words for every 100 tokens.</p><p>Context window sizes for various models:
gpt-3 – 2,048 tokens (1,500 English words)
gpt-4o – 128,000 tokens (~96,000 English words)
gpt-4.1 – 1,000,000 tokens (~750,000 English words).</p><p>You can calculate token counts for your text at <a href=https://platform.openai.com/tokenizer>https://platform.openai.com/tokenizer</a>. A key point: context size doesn’t directly determine how “smart” the model is. But having a larger context window is clearly beneficial.</p><p>When you chat in ChatGPT, there’s a limit for each conversation. When that’s exceeded, the model starts to forget (or “evict”) facts from the conversation and hallucinate.</p><p>The creators of popular models use a certain workaround for this limit. Instead of passing the entire conversation history with each new message to the model, they generate a short summary of key facts after each message and use that as the context for future prompts. This lets conversations go longer, but some facts do get lost. Summaries are, of course, made by the same models, which have the same constraints.
This hack was vital in the early days of LLMs. Now with larger context windows, the trick remains—now it saves computation resources (the bigger the context, the more resources needed to process and generate an answer).</p><p>For development, the same principle applies. However, I suspect Cursor and other editors do NOT summarize the code you share with them, to preserve response accuracy. As a result, your context window fills up even faster.</p><h2 id=problem-2-llms-use-outdated-information>Problem #2: LLMs use outdated information</h2><p>Every model is trained on specific data sets, which might not include, for example, the latest version of your favorite framework—or may not even have heard of it! For less popular technologies, there&rsquo;s scant information online, so the training set is poorer, which also leads to hallucinations, since models always try to provide some answer.</p><p>General-purpose models (GPT, Claude, Gemini, etc.) are very popular, but so are specialized ones trained on domain-specific data. For instance, code-specific models like <a href=https://openai.com/index/introducing-codex/>OpenAI Codex</a> or medical models. Since these are trained on relevant materials, their results often stand out. Still, their knowledge is limited by the training data.</p><p>Imagine being marooned on a desert island for 20 years—the world moves on, but your knowledge is frozen at some moment in time. LLMs are the same. They need regular re-training on fresh data to stay relevant.</p><p>Another crucial point: models don’t have access to the internet by default. However, all the major AI players have added the ability to search the web and use those results in your conversation. This way, you get up-to-date info even if the model was trained on old data.
How exactly this works is hard to say, but one method is building an agent on top of the <a href=https://modelcontextprotocol.io/>MCP</a> protocol. Without going into detail: think of MCP as a standard for models to interact with external services, learn their available functions, and use them.</p><h2 id=problem-3-you-have-to-explain-everything-all-over-again-every-time>Problem #3: You have to explain everything all over again every time</h2><p>Out of the box, the model doesn’t have memory. It can’t remember what you sent it. But the big players have emulated “memory” in their official clients. For example, while you chat, ChatGPT tracks facts about you that are worth saving, and later uses those facts as part of your chat’s context. This creates the illusion that the model “knows” something about you.
Memory can also be implemented via the previously mentioned <a href=https://modelcontextprotocol.io/>MCP</a> or <a href=https://en.wikipedia.org/wiki/Retrieval-augmented_generation>RAG</a>.</p><p>So if you&rsquo;re tired of repeating yourself in development, you&rsquo;ll need to find a way to emulate &ldquo;memory&rdquo; for the model. And there are solutions—more on that below.</p><h1 id=how-to-solve-these-issues-in-cursor-ai>How to Solve These Issues in Cursor AI</h1><p>These problems and workarounds might seem obvious, and I’m sure many of you have already encountered them. Still, since I have to explain these things over and over again, I want to fill that gap here.</p><p>Let’s use Cursor AI as a concrete example of solving these problems in development.</p><h2 id=1-context-window-limitations>1. Context Window Limitations</h2><p>All resources are finite, and LLMs are no different—there’s no magic here.</p><p>Here are some practices that will help you encounter hallucinations less often due to context window size:</p><h3 id=start-new-chats-as-often-as-possible>Start New Chats as Often as Possible</h3><p>Try to stick to “one problem/task/question = one chat.”
If the chat is getting large, ask for a summary to start a new thread and paste it in.
Also, think of times when, in conversation, you suddenly changed topics and your partner gave a completely off-topic reply. Models do the same when you mix topics—start a new chat for unrelated issues.</p><h3 id=only-pass-necessary-context-to-the-chat>Only Pass Necessary Context to the Chat</h3><p>You can select your whole project as context and sometimes get good results—usually only for small projects. For medium and large ones, you’ll have to be selective.</p><h3 id=switch-to-a-model-with-a-larger-context-window>Switch to a Model with a Larger Context Window</h3><p>Sometimes you need to load more context. In that case, try switching to a model with a bigger context window. But that means you&rsquo;ll need to get familiar with the models available in Cursor. <a href=https://platform.openai.com/docs/models>Here</a> you can find descriptions of OpenAI’s models.</p><h3 id=limit-project-indexing>Limit Project Indexing</h3><p>Cursor has a <code>.cursorignore</code> mechanism. This lets it ignore and not index certain parts of your project, shrinking the scope and making searches faster. This is especially useful for monorepos and large projects. More details <a href=https://docs.cursor.com/context/codebase-indexing>here</a>.</p><h2 id=2-accessing-current-information>2. Accessing Current Information</h2><p>It’s annoying when you’re already using React 19 but Cursor only gives suggestions for version 18, because that’s what it was trained on.</p><p>Cursor’s developers suggest several ways to solve this:</p><h3 id=use-the-docs-tag>Use the @docs Tag</h3><p>When you use the <code>@docs &lt;url></code> tag and give it a link to current documentation, Cursor will index those pages. When that’s done, it’ll be able to help you with the new framework features and APIs.
This works just as well for internal (private) documentation—including, say, your internal Swagger specs.</p><h3 id=use-the-web-tag>Use the @web Tag</h3><p>To search for other info on the web from right inside your IDE, use the <code>@web query</code> tag. Sure, you could Google it yourself, but this lets you work directly with those results in the same chat—pulling in StackOverflow answers, for example.</p><h3 id=use-mcp>Use MCP</h3><p>Cursor lets you connect any MCP, which can then be used in your chats as needed. One example: <a href=https://github.com/upstash/context7>MCP context7</a>, which helps you pull in up-to-date docs.</p><h2 id=3-teaching-cursor-to-remember>3. Teaching Cursor to Remember</h2><p>What’s more fun than explaining to Cursor every time how your files and methods are organized? Or how to create a new API in your project? Or whether to use external libraries versus the standard library? Or the microservice architecture and what the project’s main goal is?</p><h3 id=refer-to-old-chats>Refer to Old Chats</h3><p>Cursor has recently added the ability to reference your old chats. Use them as in, “do it the same way as in that chat,” or as a continuation of a related task.</p><h3 id=refer-to-files>Refer to Files</h3><p>Not obvious, but you can also ask: “Analyze this file/folder and do it the same way.”</p><h3 id=cursor-rules>Cursor Rules</h3><p>Cursor and other IDEs already have a solution for persistent &ldquo;memory&rdquo;: <a href=https://docs.cursor.com/context/rules>cursor rules</a>.
This is a file (or set of files, in Cursor’s case) that is automatically (or manually) passed along as part of your context. With documentation in <code>cursor rules</code>, you won’t have to repeat yourself, and Cursor will follow your standards.</p><p>Yes, this is just documentation—and yes, you still have to write it. Cursor, like a junior developer, needs guidance and explanations. Some agents (like JetBrains Junie) are making strides in analyzing existing code to try to “do the same thing.” That’s handy, but not always effective, especially with legacy code.</p><p>The good news: you can always ask Cursor to generate and save rules based on your chat (just ask directly). In fact, they&rsquo;ve recently added a <code>/Generate Cursor Rules</code> command that does exactly that. Sure, you’ll want to review and maybe ask for tweaks, but it dramatically reduces the effort of writing specs.</p><p>As a bonus: newcomers to your team can read your <code>cursor rules</code> as documentation and standards.</p><h1 id=in-conclusion>In Conclusion</h1><p>To wrap up, I invite you to think about and answer the following questions:</p><ol><li>How many tokens are in this article?</li><li>How might Cursor behave when working with a 10,000-line file?</li><li>What should you do to refactor efficiently using Cursor?</li><li>How can you have Cursor automatically run linters or builds at the end of each chat and fix errors?</li></ol><p>Effective use is entirely possible if you understand the limitations of LLMs.</p></div><div class=post__footer><span><a class=tag href=/en/tags/llm/>llm</a><a class=tag href=/en/tags/ai/>ai</a></span></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Dmitry Kuznetsov
2025</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body></html>